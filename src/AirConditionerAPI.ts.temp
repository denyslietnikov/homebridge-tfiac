// AirConditionerAPI.ts

import { EventEmitter } from 'events';
import * as dgram from 'dgram';
import * as xml2js from 'xml2js';
import { PowerState, OperationMode, FanSpeed, SwingMode, SleepModeState, FanSpeedPercentMap } from './enums.js';

export interface AirConditionerStatus {
  is_on: PowerState | string; 
  operation_mode: OperationMode | string; 
  target_temp: number;
  current_temp: number;
  fan_mode: FanSpeed | string; 
  swing_mode: SwingMode | string; 
  opt_turbo?: PowerState;
  opt_eco?: PowerState;
  opt_display?: PowerState;
  opt_beep?: PowerState;
  opt_sleep?: PowerState; 
  opt_super?: PowerState; 
  opt_sleepMode?: SleepModeState | string; 
  outdoor_temp?: number;
}

interface StatusUpdateMsg {
  IndoorTemp: string[];
  SetTemp: string[];
  BaseMode: string[];
  WindSpeed: string[];
  TurnOn: string[];
  WindDirection_H: string[];
  WindDirection_V: string[];
  Opt_display?: string[]; 
  Opt_super?: string[]; 
  Opt_sleepMode?: string[]; 
  OutdoorTemp?: string[]; 
}

// Throttle intervals in milliseconds
const SHORT_WAIT = 500;
const LONG_WAIT = 3000;

export class AirConditionerAPI extends EventEmitter {
  private readonly ip: string;
  private readonly port: number;
  public available: boolean;
  private lastSeq: number;
  private activeTimeouts: NodeJS.Timeout[] = [];
  private maxRetries: number = 3; 
  private retryDelay: number = 1000; 

  // Last time updateState actually sent a request
  private lastSyncTime: number = 0;
  // Cached last-status for throttling
  private lastStatus: AirConditionerStatus | null = null;

  constructor(ip: string, port: number = 7777, maxRetries: number = 3, retryDelay: number = 1000) {
    super();
    this.ip = ip;
    this.port = port;
    this.available = true;
    this.lastSeq = 0;
    this.maxRetries = maxRetries;
    this.retryDelay = retryDelay;
  }

  /**
   * Cleanup resources (useful for tests)
   */
  public cleanup(): void {
    // Clear all active timers
    this.activeTimeouts.forEach(timeoutId => {
      clearTimeout(timeoutId);
    });
    this.activeTimeouts = [];
  }

  private get seq(): string {
    // Return a sequence number that increments on each call to ensure uniqueness
    this.lastSeq = (this.lastSeq + 1) % 100000000;
    return this.lastSeq.toString();
  }

  private async sendCommandWithRetry(command: string, timeoutMs: number = 10000, retryCount: number = 0): Promise<string> {
    try {
      return await this.sendCommand(command, timeoutMs);
    } catch (error) {
      // If we've reached max retries, rethrow the error
      if (retryCount >= this.maxRetries) {
        this.emit('debug', `Max retries (${this.maxRetries}) reached for command, giving up.`);
        throw error;
      }

      // If it's a timeout error, retry
      if (error instanceof Error && error.message === 'Command timed out') {
        const nextRetry = retryCount + 1;
        this.emit('debug', `Command timed out, retry attempt ${nextRetry}/${this.maxRetries}`);
        
        // Wait before retrying without blocking the event loop
        await new Promise(resolve => {
          const t = setTimeout(resolve, this.retryDelay);
          if (t.unref) {
            t.unref();
          }
        });
        
        // Try again with incremented retry count
        return this.sendCommandWithRetry(command, timeoutMs, nextRetry);
      }

      // For other errors, just rethrow
      throw error;
    }
  }

  private async sendCommand(command: string, timeoutMs: number = 10000): Promise<string> {
    return new Promise<string>((resolve, reject) => {
      interface DgramSocket {
        unref?: () => void;
        on(event: string, cb: (...args: unknown[]) => void): void;
        removeAllListeners(): void;
        close(): void;
        send(
          msg: string | Buffer,
          port: number,
          ip: string,
          cb: (error: Error | null | undefined) => void
        ): void;
      }
      interface DgramModule {
        default?: { createSocket: (type: string) => DgramSocket };
        createSocket?: (type: string) => DgramSocket;
      }
      // Use the DgramModule type to access createSocket
      const dmModule = dgram as unknown as DgramModule;
      let createSocketFn: ((type: string) => DgramSocket) | undefined;
      // Prefer explicit namespace export (e.g., when tests assign dgram.createSocket)
      if ('createSocket' in dmModule && typeof dmModule.createSocket === 'function') {
        createSocketFn = dmModule.createSocket.bind(dmModule);
      } else if (dmModule.default && typeof dmModule.default.createSocket === 'function') {
        createSocketFn = dmModule.default.createSocket.bind(dmModule.default);
      }
      if (!createSocketFn) {
        throw new Error('dgram.createSocket is not a function');
      }

      const client = createSocketFn('udp4');

      // Call unref if available
      if (typeof client.unref === 'function') {
        client.unref(); 
      }

      let isResolved = false;
      // eslint-disable-next-line prefer-const
      let timeoutId: NodeJS.Timeout;

      // Function to cleanup socket and timeout
      const cleanupSocket = () => {
        if (timeoutId) {
          clearTimeout(timeoutId);
          const index = this.activeTimeouts.indexOf(timeoutId);
          if (index !== -1) {
            this.activeTimeouts.splice(index, 1);
          }
        }
        if (client && typeof client.removeAllListeners === 'function') {
          client.removeAllListeners();
        }
        if (client && typeof client.close === 'function') {
          try {
            client.close();
          } catch (err) {
            // ignore errors during close
          }
        }
      };

      timeoutId = setTimeout(() => {
        if (!isResolved) {
          isResolved = true;
          this.available = false;
          cleanupSocket();
          reject(new Error('Command timed out'));
        }
      }, timeoutMs);
      // Prevent timer from keeping the process alive (if supported)
      if (timeoutId && typeof timeoutId.unref === 'function') {
        timeoutId.unref();
      }
      this.activeTimeouts.push(timeoutId);

      client.on('message', (data) => {
        if (!isResolved) {
          isResolved = true;
          this.available = true;
          cleanupSocket();
          const response = (data as Buffer).toString();
          // Graceful fallback for UnknownCmd
          if (response.includes('<UnknownCmd>')) {
            // Log warning and resolve as no-op
            console.warn('[TFIAC] Device responded with <UnknownCmd>. Command ignored.');
            resolve(response);
            return;
          }
          resolve(response);
        }
      });
      client.on('error', (err) => {
        if (!isResolved) {
          isResolved = true;
          this.available = false;
          cleanupSocket();
          reject(err as Error);
        }
      });

      // Send command
      client.send(command, this.port, this.ip, (error) => {
        if (error && !isResolved) {
          isResolved = true;
          this.available = false;
          cleanupSocket();
          reject(error);
        }
      });
    });
  }

  async turnOn(): Promise<void> {
    await this.setAirConditionerState('is_on', PowerState.On);
  }

  async turnOff(): Promise<void> {
    // Save current operation mode before turning off
    let currentOperationMode = OperationMode.Auto;
    if (this.lastStatus && this.lastStatus.operation_mode) {
      currentOperationMode = this.lastStatus.operation_mode as OperationMode;
    }
    
    // First turn off the AC
    await this.setAirConditionerState('is_on', PowerState.Off);
    
    // Clean up any active states that should be reset when AC is turned off
    // Turn off sleep mode
    await this.setSleepState(SleepModeState.Off);
    
    // Turn off turbo mode
    await this.setTurboState(PowerState.Off);
    
    // Reset fan to Auto (which is the default)
    await this.setFanSpeed(FanSpeed.Auto);
    
    // Turn off and reset modes like sleepMode and turbo in a single command to avoid multiple beeps
    const command = `<msg msgid="SetMessage" type="Control" seq="${this.seq}">
      <SetMessage>
        <TurnOn>off</TurnOn>
        <Opt_sleepMode>off</Opt_sleepMode>
        <Opt_sleep>off</Opt_sleep>
        <Opt_super>off</Opt_super>
        <Opt_turbo>off</Opt_turbo>
        <WindSpeed>Auto</WindSpeed>
      </SetMessage>
    </msg>`;
    
    // Add debug event for turnOff command
    this.emit('debug', `Sending turnOff command: ${command}`);
    
    const response = await this.sendCommandWithRetry(command);
    
    // Add debug event for turnOff response
    this.emit('debug', `Received turnOff response: ${response}`);
    
    // Make sure the cached status reflects these changes
    if (this.lastStatus) {
      this.lastStatus.is_on = PowerState.Off;
      this.lastStatus.opt_sleepMode = SleepModeState.Off;
      this.lastStatus.opt_sleep = PowerState.Off;
      this.lastStatus.opt_turbo = PowerState.Off;
      this.lastStatus.opt_super = PowerState.Off;
      this.lastStatus.fan_mode = FanSpeed.Auto;
      // Preserve current operation mode instead of resetting to Auto
      this.lastStatus.operation_mode = currentOperationMode;
      
      // Emit the updated status
      this.emit('status', this.lastStatus);
    }
  }

  private mapWindDirectionToSwingMode(status: StatusUpdateMsg): string {
    const value =
      (status.WindDirection_H[0] === 'on' ? 1 : 0) |
      (status.WindDirection_V[0] === 'on' ? 2 : 0);
    return { 0: 'Off', 1: 'Horizontal', 2: 'Vertical', 3: 'Both' }[value] || 'Off';
  }

  private createUpdateMessage(status: AirConditionerStatus): string {
    return `<TurnOn>${status.is_on}</TurnOn>` +
           `<BaseMode>${status.operation_mode}</BaseMode>` +
           `<SetTemp>${status.target_temp}</SetTemp>` +
           `<WindSpeed>${status.fan_mode}</WindSpeed>`;
  }
